#include <iostream>
#include <vector>
#include <climits>
#include <cstdint>
#include "Connections.h"
#include "Connection.h"
#include "Signal.h"
#include "SignalRingBuffer.h"
#include "Neurons.h"
#include "Neuron.h"

// *** temporary master clock for testing
inline int32_t masterClock {0};
inline int32_t oldestEvent {0};

extern std::vector<connection::Connection> m_connPool;
extern int32_t currentConnectionSlot;
extern int32_t connectionPoolCapacity;

/* other externs used by connection*/
extern std::vector<signal::Signal> m_srb;
extern int32_t currentSignalSlot;
extern int32_t signalBufferCapacity;

extern std::vector<neuron::Neuron> m_neuronPool;
extern int32_t currentNeuronSlot;
extern int32_t neuronPoolCapacity;

namespace tconst = tcnconstants;

int main ()
{
  /**
   * @brief Test that one connection can request one signal and deliver that signal to the target neuron
   * with the correct clock value set in the signal
   * 
   * @param One input pulse into the connection, as if a neuron signalled it.
   * 
   * @return  Nothing
   * 
   * @throws  Nothing
   * 
   * POP  Each participating element is instrumented using the simple logger.
   * A neuron is created to be the target of the signal.
   * A connection is created and connected to the neuron with a clock distance.
   * A signal is allocated from the srb and delivered to a source neuron.
   * The source neuron immediately cascades and sends a pulse to its target connection.
   * The connection in turn delivers the pulse as a signal to its target neuron.
   * 
   * Success=:
   * The final neuron should receive and enqueue the signal with the correct amplitude and clock value.
   * The signals are not received and enqueued by the neuron. They are generated by the 
   * processing of a connection which acquires the signal, fills in the signal parameters then enqueues
   * one of these signals for every connection in the outgoingSignal neuron queue.
   */

    // This is the default pools capacity for testing.

   conns::Connections connections = conns::Connections(1000000); 
   neurons::Neurons neurons = neurons::Neurons(350000);
   srb::SignalRingBuffer srb = srb::SignalRingBuffer(500000);

   int32_t nextSignalSlot;


   std::cout << "Connections pool:= " << std::to_string(connectionPoolCapacity) << '\n';
   std::cout << "Neuron pool:= " << std::to_string(neuronPoolCapacity) << '\n';
   std::cout << "SRB pool:= " << std::to_string(signalBufferCapacity) << "\n\n";

   // TEST:
   // connect the first connection to the first neuron
   // get ref to first connection
   // get ref to first neuron
   //
   // connect connection to neuron
   // get first signal and poke connection
   // check if signal was delivered to neuron


  connection::Connection connRef;
  neuron::Neuron neuronRef;
  signal::Signal signalRef;

  // This is necessary because vector range operator does not provide slot number
  int32_t connSlot{};
  int32_t neuronSlot{};
  int32_t neuronSlot{};


  // pseudo slotAllocationRoutines - these return numbers
  // Both are set to start @ -1 so [0] is the first one dispensed

  connSlot = ++currentConnectionSlot;
  neuronSlot = ++currentNeuronSlot;

  // These should be refs to the first element in each pool
  connRef = m_connPool[connSlot];
  neuronRef = m_neuronPool[neuronSlot];

  // SRB is different as it can wrap  
  // Initial value should be INT32_MAX to cause immediate wrap

  if (currentSignalSlot >= signalBufferCapacity) {
      currentSignalSlot = 0;
      nextSignalSlot = 0;
  }
  else { 
      nextSignalSlot = ++currentSignalSlot; 
  }
  // srb is a vector of signal::Signal structs - returns ref to the struct
  signalRef = m_srb[nextSignalSlot];

  std::cout << "Conn/Neuron slots assigned: Conn:= " << std::to_string(connSlot) << " Neuron: = " <<
      std::to_string(neuronSlot) << "\n\n";
  std::cout << "Signalslot assigned:= " << std::to_string(nextSignalSlot) << std::endl;

  std::cout<<"Neuron refractory in slot: = " << std::to_string(m_neuronPool[0].refractoryEnd) << "\n";

  // all three elements are now addressed by a Ref from their respective pools
  // vector[x] returns ref to the element rather than making a copy
  // These should all be the filles.

  std::cout << "\n******Print three fillers from pool slot 0 \n";
  //xxxRef are the filler values inserted by the constructor - they are all the same in each pool
  connections.printConnection(connRef);
   std::cout << std::endl;
  neurons.printNeuron(neuronRef);
  std::cout << std::endl;
  // std::cout<<"Neuron current slot after assignment: = " << std::to_string(connSlot) << std::endl;
  srb.printSignal(signalRef);
  std::cout << "**********\n";

  // build the first connection
  // first get a neuron by asking Neurons to provision a neuron.
  // we already have one in neuronRef.
  // First set up the connection.
  connRef.targetNeuronSlot = currentNeuronSlot;
  connRef.temporalDistanceToTarget = 5000;      // arbitrary
  connRef.lastSignalOriginTime = 1;             // would be current clock value
  connRef.stpWeight = 1000;                     // arbitrary
  connRef.ltpWeight = 250;                      // arbitrary

  // push this onto the target neuron outgoing connections queue
  // We only have one neuron [0] so we are going to use if for outgoing and
  // incoming signals during testing of signal handling

  neuronRef.refractoryEnd = 999;


  neuronRef.outgoingSignals.push_back(&connRef);  // push a pointer onto the neuron outgoing signal vector
  // for this test put the element @ 1

  neuronRef.outgoingSignals[1] = &connRef;          // replace element zero refractoryEnd


  std::cout << "\nThis is the neuronRef we created with a pushed outgoing connRef pointer:\n";
  neurons.printNeuron(neuronRef);   // lets see if neuron was changed via the ref.

  std::cout << "\nNewly enqueued conn to Neuron from connRef\n";
  connections.printConnection(connRef);
  std::cout <<std::endl;

  std::cout << "Retrieve and print from neuron outgoingSignals vector... \n";
  connections.printConnection(*(m_neuronPool[0].outgoingSignals[0]));
  std::cout << std::endl; 
  

  // ask connection to create a new signal and enqueue it on it's target neuron.
  // in this case it's the same neuron where it is enqueue but that doesn't matter for now.
  // the neuron is the one who will ask; the connection is the one who will create signal(s)
  // 
  // Testing note: neuron refractory is set at 999; connection temporal distance 5000
  // so enqueueing of the signal should be possible.

  masterClock = 0;  // start at zero time

  // provision enqueue a signal that will cause neuron 0 to cascade

  int32_t futureSignalTime{1000};   // testing value beyond end of refractory period

  if (futureSignalTime > m_neuronPool[0].refractoryEnd)
  { // worth enqueing the signal

    // SRB is different as it can wrap  
    // currentSignalSlot was set to INT32_MAX so it should wrap to 0
 
    int32_t nextSignalSlot;

    if (currentSignalSlot >= signalBufferCapacity) {
    currentSignalSlot = 0;
    nextSignalSlot = 0;
    }
    else { 
        nextSignalSlot = ++currentSignalSlot; 
    }

    // srb is a vector of signal::Signal structs - returns ref to the struct
    signalRef = m_srb[nextSignalSlot];

    std::cout << "First signal slot allocated: " << std::to_string(nextSignalSlot) << "\n";
    srb.printSignal(signalRef);
    std::cout << std::endl;

    signalRef.actionTime = 1100;     // beyond refractory end
    signalRef.amplitude = tconst::cascadeThreshold + 1; // make signal large enough to cascade
    // ownership is used to ensure incomingSignal queues do not process the wrong signal if
    // the srb has wrapped and reused an old signal
    signalRef.owner = neuronSlot; // remember neuron that owns the signal

    std::cout << "Modified first signal slot: " << '\n';
    srb.printSignal(signalRef);

    // for testing push the signal onto neuron[0]
    // node vector queues are always pointers, never the underlying structure

    m_neuronPool[0].incomingSignals.push_back(&signalRef);

    //
    // at this point we should have a connection pointing to the same node - ok for testing
    // a signal that is enueued on neuron[0] with enough amplitude to cascade.
    // the clock is set beyond the refractory end so signal can enqueue
    // scanning the neurons should find the signal to cascade the neuron and emit signals to 
    // the connections found in the outgoingSignals vector.
    //
    // Now we call the neuron scan routing in neurons::Neurons

    neurons::Neurons neuronObject;  // we will need a default constructor for this in Neurons
    
    neuronObject.scanNeuronsForSignals();
  }

  // print out what we have in neuron[0].
  neuronRef = m_neuronPool[0];  // get the first neuron
  std::cout << "Neuron Ref [0]" << std::endl;
  neurons.printNeuron(neuronRef);
  std::cout << std::endl;

  // step through incoming and outgoing signals



  std::cout << "End of oneconnection test..." << std::endl;

  return 0;
}

