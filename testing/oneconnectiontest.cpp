#include <iostream>
#include <vector>
#include <climits>
#include <cstdint>
#include "Connections.h"
#include "Connection.h"
#include "Signal.h"
#include "SignalRingBuffer.h"
#include "Neurons.h"
#include "Neuron.h"

// *** temporary master clock for testing
extern int32_t masterClock;
inline int32_t oldestEvent {0};

extern std::vector<connection::Connection> m_connPool;
extern int32_t currentConnectionSlot;
extern int32_t connectionPoolCapacity;

/* other externs used by connection*/
extern std::vector<signal::Signal> m_srb;
extern int32_t currentSignalSlot;
extern int32_t signalBufferCapacity;

extern std::vector<neuron::Neuron> m_neuronPool;
extern int32_t currentNeuronSlot;
extern int32_t neuronPoolCapacity;

namespace tconst = tcnconstants;

int main ()
{
  /**
   * @brief Test that one connection can request one signal and deliver that signal to the target neuron
   * with the correct clock value set in the signal
   * 
   * @param One input pulse into the connection, as if a neuron signalled it.
   * 
   * @return  Nothing
   * 
   * @throws  Nothing
   * 
   * POP  Each participating element is instrumented using the simple logger.
   * A neuron is created to be the target of the signal.
   * A connection is created and connected to the neuron with a clock distance.
   * A signal is allocated from the srb and delivered to a source neuron.
   * The source neuron immediately cascades and sends a pulse to its target connection.
   * The connection in turn delivers the pulse as a signal to its target neuron.
   * 
   * Success=:
   * The final neuron should receive and enqueue the signal with the correct amplitude and clock value.
   * The signals are not received and enqueued by the neuron. They are generated by the 
   * processing of a connection which acquires the signal, fills in the signal parameters then enqueues
   * one of these signals for every connection in the outgoingSignal neuron queue.
   */

  // This is the default pools capacity for testing.
  // Create signals and connections before the neurons as neuron creation references them.

  srb::SignalRingBuffer srb = srb::SignalRingBuffer(500000); 
  conns::Connections connections = conns::Connections(1000000);
  neurons::Neurons neurons = neurons::Neurons(15000);

  // These objects are used for accessing printer routines
  conns::Connections* connObj = &connections;
  neurons::Neurons* neuronObj = &neurons;
  srb::SignalRingBuffer* srbObj = &srb;

  // Indexes into pools used as vector ptrs are too volatile
  int32_t connIdx;
  int32_t neuronIdx;
  int32_t signalIdx;

  int32_t nextSignalSlot;   // carries the next signal slot after pseudo-allocation.
  

   std::cout << "Connections pool:= " << std::to_string(connectionPoolCapacity) << '\n';
   std::cout << "Neuron pool     := " << std::to_string(neuronPoolCapacity) << '\n';
   std::cout << "SRB pool        := " << std::to_string(signalBufferCapacity) << "\n\n";

   // TEST:
   // connect the first connection to the first neuron
   // get ref to first connection
   // get ref to first neuron
   //
   // connect connection to neuron
   // get first signal and poke connection
   // check if signal was delivered to neuron



  // This is necessary because vector range operator does not provide slot number
  int32_t connSlot{};
  int32_t neuronSlot{};
  int32_t signalSlot{};

  // pseudo slotAllocationRoutines - these return numbers
  // Both are set to start @ 0 so [0] is the never dispensed and should never process

  connSlot = ++currentConnectionSlot;
  neuronSlot = ++currentNeuronSlot;
  signalIdx = signalSlot;



  // These should be slots to the first element in each pool
  std::cout << "\nIndexes for each FIRST IN POOL.\n";
  std::cout << "\nconnSlot:= " << std::to_string(connSlot) <<
            " neuronSlot:= " << std::to_string(neuronSlot) << 
            " signalSlot:= " << std::to_string(signalSlot) << std::endl;


  std::cout << '\n';
  connections.printConnectionFromIndex(connSlot);
  std::cout << std::endl;

  neurons.printNeuronFromIndex(neuronSlot);
  std::cout << '\n';

  srb.printSignalFromIndex(signalIdx);

  std::cout << std::endl;

  std::cout << "\nGOOD TO THIS POINT - EVERYTHING AS EXPECTED\n";

  //show incoming and outgoing signals first entries - which should be empty fakes
  std::cout << "\nUsing neuron[0]  - should see first slot empty fake signals & connections";
  std::cout << "\nFirst neuron index into signalPool\n";
  
  // std::cout << "\nneuronPtr->incomingSignals[0]:= " << 
  // std::to_string(neuronPtr->incomingSignals[0]->actionTime) << std::endl;
  
  // neuronPtr = &m_neuronPool[neuronSlot];


  std::cout << "\nFirst neuron first signal slot\n";
  srb.printSignalFromIndex(m_neuronPool[0].incomingSignals[0]);

  std::cout << "\nFirst neuron first connection slot\n";
  connections.printConnectionFromIndex(m_neuronPool[0].outgoingSignals[0]);
  std::cout << "\n";
  


  // SRB is different as it can wrap  
  // Initial value should be INT32_MAX to cause immediate wrap

  if (currentSignalSlot >= signalBufferCapacity) {
      currentSignalSlot = 0;
      nextSignalSlot = 0;
  }
  else { 
      nextSignalSlot = ++currentSignalSlot; 
  }
  // srb is a vector of signal::Signal structs - returns ref to the struct
  // signalPtr= &m_srb[nextSignalSlot];
  // !!! no more ptrs when vectors are in use

  std::cout << "Conn/Neuron slots assigned: Conn:= " << std::to_string(connSlot) << " Neuron: = " <<
      std::to_string(neuronSlot) << "\n";
  std::cout << "Signal slot assigned:= " << std::to_string(nextSignalSlot) << std::endl;

  // all three elements are now addressed by a Ref from their respective pools
  // vector[x] returns ref to the element rather than making a copy
  // These should all be the fillers.

  connIdx = connSlot;
  neuronIdx = neuronSlot;
  signalIdx = 1;

  std::cout << "\n****** Print three fillers from pool slot 0 \n";
  //xxxRef are the filler values inserted by the constructor - they are all the same in each pool
  connections.printConnectionFromIndex(connIdx);
   std::cout << std::endl;
  neurons.printNeuronFromIndex(neuronIdx);
  std::cout << std::endl;
  // std::cout<<"Neuron current slot after assignment: = " << std::to_string(connSlot) << std::endl;
  srb.printSignalFromIndex(signalIdx);
  std::cout << "**********\n";

  // build the first connection
  // first get a neuron by asking Neurons to provision a neuron.
  // we already have one in neuronIdx.
  // First set up the connection.
  m_connPool[connIdx].targetNeuronSlot = currentNeuronSlot;
  m_connPool[connIdx].temporalDistanceToTarget = 5000;      // arbitrary
  m_connPool[connIdx].lastSignalOriginTime = masterClock;   // would be current clock value
  m_connPool[connIdx].stpWeight = 1000;                     // arbitrary
  m_connPool[connIdx].ltpWeight = 250;                      // arbitrary

  // push this onto the target neuron outgoing connections queue
  // We only have one neuron [0] so we are going to use if for outgoing and
  // incoming signals during testing of signal handling

  // Make sure neuron is out of refractory period so signals will enqueue
  // Master clock is set @ 1000

  m_neuronPool[neuronIdx].refractoryEnd = 200;


  // neuronRef.outgoingSignals.push_back(&connRef);  // push a pointer onto the neuron outgoing signal vector
  // for this test put the element @ 1 - outgoing length now 2

  std::cout << "\n>>> ConnRef before we push it into neuron[0]:= \n";
  connections.printConnectionFromIndex(connIdx);

  m_neuronPool[neuronIdx].outgoingSignals[0] = connIdx;          
  // This should leave the outgoing signal length @ 1

  std::cout << "\nAfter modifying outgoingSignals in neuron[0]\n";
  neurons.printNeuronFromIndex(neuronIdx);

  
  std::cout << "\nPrint outgoingSignal slot tempDist:= " << 
            std::to_string(m_connPool[m_neuronPool[neuronIdx].outgoingSignals[0]].temporalDistanceToTarget) << std::endl;

  std::cout << "\nNewly enqueued conn to Neuron from connRef\n";

  // connections.printConnectionFromIndex(m_neuronPool[neuronIdx].outgoingSignals[0]);
  // std::cout <<std::endl;

  std::cout << "Retrieve and print from neuron outgoingSignals vector using neuronIdx:= " <<
            std::to_string(neuronIdx) << '\n';
  connections.printConnectionFromIndex(m_neuronPool[neuronIdx].outgoingSignals[0]);
  //
  // For whatever reason the refence below does not work...have to use neuronRef to
  // get the correct answer.
  //
  // connections.printConnectionFromPointer((m_neuronPool[0]).outgoingSignals[0]);
  // Because need FromIndex not FromPointer - intellisense figured it out...
  // 
  std::cout << std::endl; 
  

  // Ask connection to create a new signal and enqueue it on it's target neuron.
  // In this case it's the same neuron where it is enqueue but that doesn't matter for now.
  // the neuron is the one who will ask; the connection is the one who will create signal(s)
  // 
  // Testing note: neuron refractory is set at 200; connection temporal distance 5000 and
  // masterClock to 1000 so enqueueing of the signal should be possible.
  // ERROR: If neuron refractory is greater than current clock then neuron is still
  //        refractory and should not enqueue any signals

  globalNextEvent = 1000;
  masterClock = globalNextEvent;  // Start so neuron is out of refractory set at 200

  // For testing fix up the neuron's next event to be current masterClock

  m_neuronPool[neuronIdx].nextEvent = masterClock;  // This is the clock tick we are processing


  // provision enqueue a signal that will cause neuron 0 to cascade

  int32_t futureSignalTime{1000};   // testing value beyond end of refractory period

  if (masterClock > m_neuronPool[neuronIdx].refractoryEnd)
  { 
    std:: cout << "\nmasterClock vs. refractoryEnd: = " << std::to_string(masterClock) <<
        " vs. " << std::to_string(m_neuronPool[neuronIdx].refractoryEnd) << '\n';

    // if it's worth enqueing the signal

    // SRB is different as it can wrap   
    // PSEUDO-ALLOCATION for srb

    if (currentSignalSlot >= signalBufferCapacity) {
    currentSignalSlot = 0;
    nextSignalSlot = 0;
    }
    else { 
        nextSignalSlot = ++currentSignalSlot; 
    }

    // srb is a vector of signal::Signal structs - returns ref to the struct
    // signalPtr = &m_srb[nextSignalSlot];
    // Just use the nextSignalSlot index into srb - don't bother with refs or pointers

    std::cout << "\nSRB pseudo-allocation <<<<<<<\nnextSignalSlot: ="  << std::to_string(nextSignalSlot) << "\n";
    srb.printSignalFromIndex(nextSignalSlot);   // should be a proto signal from srb constructor time
    std::cout << std::endl;

    m_srb[nextSignalSlot].actionTime = 1100;     // beyond neuron refractory end
    m_srb[nextSignalSlot].amplitude = tconst::cascadeThreshold + 1; // make signal large enough to cascade
    // ownership is used to ensure incomingSignal queues do not process the wrong signal if
    // the srb has wrapped and reused an old signal
    m_srb[nextSignalSlot].owner = neuronSlot; // remember neuron that owns the signal

    std::cout << "Modified first signal slot: " << '\n';
    srb.printSignalFromIndex(nextSignalSlot);
    std::cout << std::endl;

    // For testing push the signal onto current neuron
    // In future testing we will scan the outgoing signal queue and push signal onto the neuron
    // designated by the outgoing connection target

    m_neuronPool[neuronIdx].incomingSignals.push_back(nextSignalSlot);

    // Have to add this scan of incomingSignals every time we enque a new signal.

    std::cout << "\nmasterClock:= " << std::to_string(masterClock) << '\n';

    m_neuronPool[neuronIdx].nextEvent = INT32_MAX;  // Ensure we capture the next lowest event from signals
    globalNextEvent = INT32_MAX;                    // Ensure we capture the next lowest neuron event.
  
    for (int32_t signalScanIdx : m_neuronPool[neuronIdx].incomingSignals) // This is the c++ forEach
    // for (int32_t signalScanIdx=0; signalScanIdx < m_neuronPool[neuronIdx].incomingSignals.size(); ++signalScanIdx)
    {
      // Note: forEach delivers the index into the srb pool, not the incoming signals vector
      std::cout << "\nsignalScanIdx:= " << std::to_string(signalScanIdx);
      std::cout << "\nincomingSignal size:= " << std::to_string(m_neuronPool[neuronIdx].incomingSignals.size());
      std::cout << "\nincomingSignal clock:= " << 
        std::to_string(m_srb[signalScanIdx].actionTime);

      if (m_srb[signalScanIdx].actionTime > masterClock)
      {
        // This test should drop any proto signals with INT32_MIN actionTimes
        // Only interested in future events
        // Oldest signal/smallest clock is the next event of interest
        // nextEvent alway primed with INT32_MAX so at least one signal will qualify
        m_neuronPool[neuronIdx].nextEvent = 
          (m_srb[signalScanIdx].actionTime < m_neuronPool[neuronIdx].nextEvent) ? 
                m_srb[signalScanIdx].actionTime : m_neuronPool[neuronIdx].nextEvent;
      }
    }
    // make globalNextEvent the oldest of the neuronEvents.
    globalNextEvent = (globalNextEvent <= m_neuronPool[neuronIdx].nextEvent) ? 
                          globalNextEvent : m_neuronPool[neuronIdx].nextEvent;

    std::cout << "\n\nNeuron next event:= " << std::to_string(m_neuronPool[neuronIdx].nextEvent);
    std::cout << "\n\nGlobal next event:= " << std::to_string(globalNextEvent);
    // node vector queues are always indexes, never the underlying structure

    //
    // at this point we should have a connection pointing to the same node - ok for testing
    // a signal that is enueued on neuron[0] with enough amplitude to cascade.
    // the clock is set beyond the refractory end so signal can enqueue
    // scanning the neurons should find the signal to cascade the neuron and emit signals to 
    // the connections found in the outgoingSignals vector.
    //
    // Now we call the neuron scan routing in neurons::Neurons

    std::cout << "\nShow neuron entries before we scan\n";

    // neuron::Neuron* tempNeuronPtr = &m_neuronPool[0];
    // No more pointers to vectors

    int32_t tempNeuronIdx = 0;
    std::cout << "\nNeuron [0]\n";
    std::cout << "Refractory end: " << std::to_string(m_neuronPool[tempNeuronIdx].refractoryEnd) << std::endl;
    neurons.printNeuronFromIndex(tempNeuronIdx);

    tempNeuronIdx = 1;
    std::cout << "\nExpect to see an empty unused neuron\n";
    std::cout << "Neuron [1]\n";
    std::cout << "Refractory end: " << std::to_string(m_neuronPool[tempNeuronIdx].refractoryEnd) << std::endl;
    neurons.printNeuronFromIndex(tempNeuronIdx);
    std::cout << '\n';

    neurons.scanNeuronsForSignals();
  }


  // Show signals now enqued on neuron[0]

  std::cout << "\nNeuron index: = " << std::to_string(neuronIdx);

  for (int32_t sigRef : m_neuronPool[neuronIdx].incomingSignals)
  {
    srb.printSignalFromIndex(sigRef);
    std::cout << '\n';
  }
  std::cout << "End of oneconnection test..." << std::endl;

  return 0;
}

